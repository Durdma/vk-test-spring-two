Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Запуск и необходимые компоненты:
   Запуск производится из корня проекта:
   ```
   go run main.go
   ```
   
   Для корректной работы необходима установленная на машину Redis. Пароль и имя пользователя не использовались в реализации.
   Установить конфигурацию можно в файле ```config/config.yml```

# Ход мысли:

Интерфейс имеет один метод Check, который имеет следующую сигнатуру:
```Check(ctx context.Context, userID int64) (bool, error)```

На вход метода принимается контекст запроса и id пользователя, который обращается к нашему приложению.
Метод возвращает bool-переменную, которая сообщает пройден флуд-контроль или нет. Также возвращается ошибка, которая может быть комментарием к полученному результату, так и сообщением о критической ошибке.

1) В начале определим структуру, которая будет хранить в себе всю необходимую информацию для реализации интерфейса.
   ```go
    type FloodControl struct {
	    maxNumberOfRequests int64
	    maxNumberOfRetries  int
	    floodInterval       time.Duration
	    retryInterval       time.Duration

	    redisPool           *redis.Pool}
   ```
В данной структуре будет храниться:
1) количество запросов, которое не должен превысить пользователь(```maxNumberOfRequests```); 
2) период времени, за которое не должен быть превышен лимит запросов (```floodInterval```);
3) количество повторов обращения к БД (```maxNumberOfRetries```), подробнее об этом будет далее;
4) интервал между новым обращением к БД (```retryInterval```);
5) Пул соединений к Redis DB.

По условию задания флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных.
Для решения этой задачи была выбрана БД "Redis".
Redis - это БД типа ключ-значение. Она достаточно легковесна и быстра. Для решения данной задачи нам нет необходимости использовать БД, где есть инструменты для создания и управления сложными сущностями и связями между ними.
В рамках этой задачи нам необходимо хранить ```userId```, который мы будем использовать в качестве ключа в БД, количество обращений этого пользователя к приложению.
Еще одним плюс Redis является встроенный механизм "Expire", который позволяет установить период хранения записи в БД.
На основе всех вышеописанных преимуществ, можно сделать вывод, что это является если неоптимальным, то по крайней мере неплохим решением для данной задачи.

Далее был составлен файл конфигурации "config.yml", в котором можно задать параметры работы флуд-контроля. В данной задаче не говорится, о реализации механизмов авторизации и аутентификации, поэтому
предполагаем, что для решения данной задачи используем БД без пароля и имени пользователя.
```yaml
redis:
   host: localhost
   port: 6379
   db: 3

flood-control:
   maxNumberOfRequests: 3  #Количество requests, после которого происходит блокирование доступа к БД
   floodControlTTL: 40s    #Время за которое не должен быть превышен предел
   retryInterval: 1s       #Время через которое делается повторное обращение к БД
   maxNumberOfRetries: 10  #Максимальное количество повторных запросов к БД
```

С помощью "github.com/spf13/viper" был реализован механизм чтения конфигурации.
Далее был реализован "уровень репозитория" для флуд-контроля. ```redisdb.NewRedisPool``` - функция инициализирует пул подключений к Redis, по данным, полученным из конфига.
Далее была реализована сама функция ```Check```.
Так как данная функция может быть запущена на нескольких экземплярах приложения одновременно, то необходимо было установить безопасное взаимодействие БД, то есть необходимо было избежать неконтролируемого состояния гонки.
То есть необходимо было реализовать механизм синхронизации обращений к БД. Для этого было решено использовать механизмы синхронизации, предоставляемые redis.
"github.com/go-redsync/redsync/v4" - позволяет из кода вызывать механизмы синхронизации redis.
Главным механизмом здесь является "mutex", который может находиться в двух состояниях: открытый и закрытый.
Если в redis мы хотим ограничить доступ к какой-либо записи из другого приложения, пока над ней в порядке очереди не будут выполнены предыдущие операции, то необходимо создать в каждом приложении мьютекс с одним и тем же именем.
Например:
```go
    mutex := rs.NewMutex(fmt.Sprintf("mutex:%v", key))
```

Данный код создает мьютекс с именем, в котором содержится ид пользователя. Как только будет вызван метод ```mutex.Lock()```, мьютексы с таким же именем не смогут вызвать этот метод, точнее будет возвращаться ошибка: "lock already taken, locked nodes: [0]",
что говорит о том, что доступ заблокирован, пока первый мьютекс не вызовет метод ```mutex.Unlock()```.
Чтобы все приложения доносили информацию до БД и нигде не происходила из-за блокировок потеря информации, в функцию "Check" был добавлен цикл, который определенное количество раз (```maxNumberOfRetries```), пытается вызвать ```mutex.Lock()```,
с интервалом в ```retryInterval```. Если все попытки подключения были использованы, а подключение так и не удалось, то возвращается сигнал о том, что проверка не была пройдена и ошибка, сообщающая об этом.